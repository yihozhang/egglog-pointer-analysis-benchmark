
;; functions
(relation function_name (String))
(input function_name "function.csv")
(relation function_nparams (String i64))
(input function_nparams "function_nparams.csv")
(relation function_param (String i64 String))
(input function_param "function_param.csv")
(relation instruction_in_function (String String))
(input instruction_in_function "instruction_in_function.csv")

;; instructions
(relation instruction_assigns_to (String String))
(input instruction_assigns_to "instruction_assigns_to.csv")
(relation assign_instruction (String String))
(input assign_instruction "assign_instruction.csv")
(relation load_instruction (String))
(input load_instruction "load_instruction.csv")
(relation load_instruction_address (String String))
(input load_instruction_address "load_instruction_address.csv")
(relation store_instruction_value (String String))
(input store_instruction_value "store_instruction_value.csv")
(relation store_instruction_address (String String))
(input store_instruction_address "store_instruction_address.csv")

(relation call_instruction_arg (String i64 String))
(input call_instruction_arg "call_instruction_arg.csv")
(relation call_instruction_fn_target (String String))
(input call_instruction_fn_target "call_instruction_fn_target.csv")

(relation ret_instruction (String))
(input ret_instruction "ret_instruction.csv")
(relation ret_instruction_value (String String))
(input ret_instruction_value "ret_instruction_value.csv")

(relation constant_points_to (String String))
(input constant_points_to "constant_points_to.csv")
(relation constant_ptr_points_to (String String))
(input constant_ptr_points_to "constant_ptr_points_to.csv")
(relation allocated_at (String String))
(input allocated_at "allocated_at.csv")
(relation alloc_subregion_root (String String))
(input alloc_subregion_root "alloc_subregion_root.csv")

(datatype Allocation (A String))

(function expr_points_to (String) Allocation)
(function ptr_points_to (Allocation) Allocation)

(rule (
    (constant_points_to e a)
)(
    (union (expr_points_to e) (A a))
))

(rule (
    (constant_ptr_points_to a b)
)(
    (union (ptr_points_to (A a)) (A b))
))

(rule (
    (allocated_at a v)
)(
    (union (expr_points_to v) (A a))
))

;; assign
(rule (
    (assign_instruction v e)
    (= (expr_points_to e) a)
)(
    (union (expr_points_to v) a)
))

;; load
(rule (
    (load_instruction_address i u)
    (instruction_assigns_to i e)
    (= (expr_points_to u) a)
    (= (ptr_points_to a) b)
)(
    (union (expr_points_to e) b)
))

;; store
(rule (
    (store_instruction_address i v)
    (store_instruction_value i u)
    (= (expr_points_to v) a)
    (= (expr_points_to u) b)
)(
    (union (ptr_points_to a) b)
))

;; field (insensitive)
(rule (
    (alloc_subregion_root ef e)
    (= (ptr_points_to (A ef)) a)
)(
    (union (ptr_points_to (A e)) a)
))

(rule (
    (alloc_subregion_root ef e)
    (= (ptr_points_to (A e)) a)
)(
    (union (ptr_points_to (A ef)) a)
))

;; If `f(t* x)`, `f(v)`, and `v -> a`, then `x -> a`.
(rule (
    (function_name f)
    (function_param f idx x)
    (call_instruction_fn_target instr f)
    (call_instruction_arg instr idx v)
    (= (expr_points_to v) a)
)(
    (union (expr_points_to x) a)
))

;; If `return u` in `f` and `u -> a`, then `f(z) -> a`.
;; also need to do assigns_to, so that not only expr, but also vars are unified.
(rule (
    (instruction_in_function ret_instr f)
    (call_instruction_fn_target call_instr f)
    (ret_instruction_value ret_instr u)
    (instruction_assigns_to call_instr to_var)
    (= (expr_points_to u) a)
)(
    (union (expr_points_to to_var) a)
))
;; (run 13)
(run 100000)

(print-size expr_points_to)
(print-size ptr_points_to)